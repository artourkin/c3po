package rules

import java.util.List
import java.util.Set
import java.lang.StringBuilder

import com.petpet.c3po.datamodel.Element
import com.petpet.c3po.datamodel.MetadataRecord
import com.petpet.c3po.datamodel.MetadataRecord.Status
import com.petpet.c3po.datamodel.Source
import com.petpet.c3po.api.dao.Cache
import com.petpet.c3po.dao.MetadataUtil

global com.petpet.c3po.api.dao.Cache cache;
global com.petpet.c3po.adaptor.rules.drools.LogCollector log;


/**
 * This is run every time, once, before all others
 *
rule "Initialize"
        salience 1000
    when 
    then
        log.debug("DR Running" );   
end
/**/

/**
 * This rule checks if there exists a property, marked as conflicting, that has
 * no more other properties that provoke the conflict. 
 * If no conflicting properties are found, the status is set to "SINGLE_RESULT"
 * and all (in fact non-)conflicting records are merged together.
 *
 * This rule has a high priority, so whenever we see a property is conflicting, 
 * there must be at least one property with a conflicting value.
 */
rule "Single value, no more Conflict - Resolution"
        salience 990
    when 
        $e : Element()

        $md1 : MetadataRecord(
            status=="CONFLICT"
        ) from $e.metadata

        Number( intValue == 0 ) from accumulate( $m : MetadataRecord( 
                property.id == $md1.property.id,
                value != $md1.value
            ) from $e.metadata;
                count($m)
        )

        $mdsSame : List() from accumulate( $m : MetadataRecord( 
                this != $md1, 
                property.id == $md1.property.id,
                value == $md1.value
            ) from $e.metadata;
                collectList($m)
        )

    then
        log.debug("no more conflicts on "+$md1.getProperty().getId());
        
        $md1.setStatus(Status.SINGLE_RESULT.toString());
        modify($e) {
            mergeMetadata($md1, $mdsSame)
        }
        log.debug("    -> merge and set status to Single Result!");
end



/**
 * If Exiftool reports another format than others AND at least 2 times other tools claim it to be "Portable Document Format", 
 * ignore Exiftool (and the like).
 */
rule "Resolve Exiftool PDF format string"
        salience 100
    when 
        $e : Element()
        $mdBad : MetadataRecord(
            status=="CONFLICT", 
            property.id == "format", 
            MetadataUtil.isFromTool(cache, this, "Exiftool") 
        ) from $e.metadata
        $badSources : List ($toolOpinion : size) from accumulate( $id: String() from $mdBad.sources;
            collectList( cache.getSource($id) ) 
        )

        $mdGood : MetadataRecord(
            status=="CONFLICT", 
            property.id == "format", 
            ! MetadataUtil.isFromTool(cache, this, "Exiftool"), 
            value == "Portable Document Format"
        ) from $e.metadata
        $goodSources : List (size >= 2*$toolOpinion) from accumulate( $id: String() from $mdGood.sources;
            collectList( cache.getSource($id) ) 
        )
        
    then
        log.debug("Exiftool PDF format string issue: ");
        log.debug("    bad value: "+ $mdBad.getValue());
        for(Source source : (List<Source>)$badSources) {
            log.debug("        Source: "+source.getName()+" "+source.getVersion());         
        }
        log.debug("    good value: "+ $mdGood.getValue());
        for(Source source : (List<Source>)$goodSources) {
            log.debug("        Source: "+source.getName()+" "+source.getVersion());         
        }
        
        modify ($e) {
            ignoreMetadata($mdBad)
        }
        log.debug("    -> ignore "+$mdBad);
        
end

/**
 * Treat application/rtf mimetypes as text/rtf 
 */
rule "set application/rtf mimetypes to text/rtf"
        salience 160
    when 
        $e : Element()
        $md : MetadataRecord(
            property.id == "mimetype",
            value matches ".*application/rtf.*"
        ) from $e.metadata

    then
        log.debug("mimetype=application/rtf issue: ");
        log.debug("    mimetype value: "+ $md.getValue());
        for(String sourceID : $md.getSources()) {
            Source source = cache.getSource(sourceID);
            log.debug("        Source: "+source.getName()+" "+source.getVersion());         
        }
        
        $md.setValue("text/rtf");
        modify ($e) {
            getId()
        }
        log.debug("    -> set mimetype to \"text/rtf\"!");
        
end

/**
 * set RTF format to Rich Text Format
 */
rule "set RTF format to Rich Text Format"
        salience 160
    when 
        $e : Element()
        $mdFormat : MetadataRecord(
            property.id == "format",
            value == "RTF"
        ) from $e.metadata
        $mdMime : MetadataRecord(
            property.id == "mimetype",
            value matches ".*(text|application)/rtf.*"
        ) from $e.metadata

    then
        log.debug("RTF format string issue: ");
        log.debug("    format: "+ $mdFormat.getValue());
        for(String sourceID : $mdFormat.getSources()) {
            Source source = cache.getSource(sourceID);
            log.debug("        Source: "+source.getName()+" "+source.getVersion());         
        }
        
        $mdFormat.setValue("Rich Text Format");
        modify ($e) {
            getId()
        }
        log.debug("    -> set format to \"Rich Text Format\"!");
        
end

/**
 * If some tools report a mimetype as "text/plain" (and all those tools report the same format string) 
 * and some other tools report "text/*" (and all agree on the same format string), ignore the text/plain mimetype and format.
 */
rule "ignore text/plain and corresponding format if more precisise text/* available"
        salience 150
    when 
        $e : Element()
        $mdBadMime : MetadataRecord(
            status=="CONFLICT", 
            property.id == "mimetype",
            value == "text/plain"
        ) from $e.metadata
        $mdBadFormat : MetadataRecord(
            status=="CONFLICT", 
            property.id == "format",
            MetadataUtil.haveSameSources(this, $mdBadMime)
        ) from $e.metadata
        
        $mdGoodMime : MetadataRecord(
            status=="CONFLICT", 
            property.id == "mimetype", 
            value != "text/plain",
            value str[startsWith] "text/"
        ) from $e.metadata
        $mdGoodFormat : MetadataRecord(
            status=="CONFLICT", 
            property.id == "format",
            MetadataUtil.haveSameSources(this, $mdGoodMime)
        ) from $e.metadata
        
    then
        log.debug("format/mimetype=text/plain issue: ");
        log.debug("    mimetype: "+ $mdBadMime.getValue());
        log.debug("    format:   "+ $mdBadFormat.getValue());
        for(String sourceID : $mdBadMime.getSources()) {
            Source source = cache.getSource(sourceID);
            log.debug("        Source: "+source.getName()+" "+source.getVersion());         
        }
        log.debug("    mimetype: "+ $mdGoodMime.getValue());
        log.debug("    format:   "+ $mdGoodFormat.getValue());
        for(String sourceID : $mdGoodMime.getSources()) {
            Source source = cache.getSource(sourceID);
            log.debug("        Source: "+source.getName()+" "+source.getVersion());         
        }
        
        modify ($e) {
            ignoreMetadata($mdBadMime),
            ignoreMetadata($mdBadFormat)
        }
        log.debug("    -> ignore "+$mdBadMime);
        log.debug("    -> ignore "+$mdBadFormat);
        
end

/**
 * If Jhove report a mimetype as "text/html" (and all those tools report the same format string) 
 * and some other tools report "application/xhtml+xml" (and all agree on the same format string), ignore the text/html mimetype and format.
 */
rule "ignore text/html and corresponding format by Jhove (and others) if application/xhtml+xml is available"
        salience 150
    when 
        $e : Element()
        $mdBadMime : MetadataRecord(
            status=="CONFLICT", 
            property.id == "mimetype",
            value == "text/html",
            MetadataUtil.isFromTool(cache, this, "Jhove") 
        ) from $e.metadata
        $mdBadFormat : MetadataRecord(
            status=="CONFLICT", 
            property.id == "format",
            MetadataUtil.haveSameSources(this, $mdBadMime)
        ) from $e.metadata

        $mdGoodMime : MetadataRecord(
            status=="CONFLICT", 
            property.id == "mimetype", 
            value == "application/xhtml+xml"
        ) from $e.metadata
        $mdGoodFormat : MetadataRecord(
            status=="CONFLICT", 
            property.id == "format",
            MetadataUtil.haveSameSources(this, $mdGoodMime)
        ) from $e.metadata
        
    then
        log.debug("text/html vs. application/xhtml+xml issue: ");
        log.debug("    mimetype value: "+ $mdBadMime.getValue());
        log.debug("    format value:   "+ $mdBadFormat.getValue());
        for(String sourceID : $mdBadMime.getSources()) {
            Source source = cache.getSource(sourceID);
            log.debug("        Source: "+source.getName()+" "+source.getVersion());         
        }
        log.debug("    mimetype value: "+ $mdGoodMime.getValue());
        log.debug("    format value:   "+ $mdGoodFormat.getValue());
        for(String sourceID : $mdGoodMime.getSources()) {
            Source source = cache.getSource(sourceID);
            log.debug("        Source: "+source.getName()+" "+source.getVersion());         
        }
        
        modify ($e) {
            ignoreMetadata($mdBadMime),
            ignoreMetadata($mdBadFormat)
        }
        log.debug("    -> ignore "+$mdBadMime);
        log.debug("    -> ignore "+$mdBadFormat);
end

/**
  * if Exiftool and Droid both report power point presentation, ignore others, because they are typically right
 */
rule "if Exiftool and Droid report ppt, ignore others"
        salience 100
    when
        $e : Element()
        $mdGoodFormat1 : MetadataRecord(
            status=="CONFLICT",
            property.id == "format",
            MetadataUtil.isFromTool(cache, this, "Exiftool"),
            value == "PPT"
        ) from $e.metadata

        $mdGoodFormat2 : MetadataRecord(
            status=="CONFLICT",
            property.id == "format",
            MetadataUtil.isFromTool(cache, this, "Droid"),
            value == "Microsoft Powerpoint Presentation"
        ) from $e.metadata

        $mdBadMime : MetadataRecord(
            status=="CONFLICT",
            property.id == "mimetype",
            ! MetadataUtil.isFromTool(cache, this, "Exiftool"),
            ! MetadataUtil.isFromTool(cache, this, "Droid")
        ) from $e.metadata
        $mdBadFormat : MetadataRecord(
            status=="CONFLICT",
            property.id == "format",
            ! MetadataUtil.isFromTool(cache, this, "Exiftool"),
            ! MetadataUtil.isFromTool(cache, this, "Droid")
        ) from $e.metadata


    then
        log.debug("Exiftool+Droid PPT format string issue: ");
        log.debug("    mimetype value: "+ $mdBadMime.getValue());
        log.debug("    format value:   "+ $mdBadFormat.getValue());
        for(String sourceID : $mdBadMime.getSources()) {
            Source source = cache.getSource(sourceID);
            log.debug("        Source: "+source.getName()+" "+source.getVersion());
        }
        log.debug("    format1 value: "+ $mdGoodFormat1.getValue());
        log.debug("    format2 value:   "+ $mdGoodFormat2.getValue());

        modify ($e) {
            ignoreMetadata($mdBadFormat),
            ignoreMetadata($mdBadMime)
        }
        log.debug("    -> ignore "+$mdBadFormat);
        log.debug("    -> ignore "+$mdBadMime);

end

/**
  * If Jhove and Droid both report xhmtl, ignore others, because they are typically right
 */
rule "if Jhove and Droid report xhtml, ignore others"
        salience 200
    when
        $e : Element()
        $mdGoodFormat1 : MetadataRecord(
            status=="CONFLICT",
            property.id == "format",
            MetadataUtil.isFromTool(cache, this, "Jhove"),
            value == "XHTML"
        ) from $e.metadata

        $mdGoodFormat2 : MetadataRecord(
            status=="CONFLICT",
            property.id == "format",
            MetadataUtil.isFromTool(cache, this, "Droid"),
            value == "Extensible Hypertext Markup Language"
        ) from $e.metadata

        $mdGoodMime1 : MetadataRecord(
            status=="CONFLICT",
            property.id == "mimetype",
            MetadataUtil.haveSameSources(this, $mdGoodFormat1)
        ) from $e.metadata

        $mdGoodMime2 : MetadataRecord(
            status=="CONFLICT",
            property.id == "mimetype",
            MetadataUtil.haveSameSources(this, $mdGoodFormat2)
        ) from $e.metadata

        $mdBadMime : MetadataRecord(
            status=="CONFLICT",
            property.id == "mimetype",
            ! MetadataUtil.isFromTool(cache, this, "Jhove"),
            ! MetadataUtil.isFromTool(cache, this, "Droid")
        ) from $e.metadata
        $mdBadFormat : MetadataRecord(
            status=="CONFLICT",
            property.id == "format",
            MetadataUtil.haveSameSources(this, $mdBadMime)
        ) from $e.metadata


    then
        log.debug("Jhove+Droid PPT xhtml string issue: ");
        log.debug("    mimetype value: "+ $mdBadMime.getValue());
        log.debug("    format value:   "+ $mdBadFormat.getValue());
        for(String sourceID : $mdBadMime.getSources()) {
            Source source = cache.getSource(sourceID);
            log.debug("        Source: "+source.getName()+" "+source.getVersion());
        }
        log.debug("    format1 value: "+ $mdGoodFormat1.getValue());
        log.debug("    format2 value:   "+ $mdGoodFormat2.getValue());

        modify ($e) {
            ignoreMetadata($mdBadFormat),
            ignoreMetadata($mdBadMime),
            ignoreMetadata($mdGoodFormat2),
            ignoreMetadata($mdGoodMime2)
        }
        log.debug("    -> ignore "+$mdBadFormat);
        log.debug("    -> ignore "+$mdBadMime);

end

/**
 * REPORT Rules
 */

rule "REPORT: element with conflicts"
        salience 0
    when 
        $e : Element()
        MetadataRecord( status=="CONFLICT", $conflictingProperty : property.id) from $e.metadata
        
        $conflicts : List() from collect(
                        MetadataRecord(status=="CONFLICT",  property.id == $conflictingProperty) from $e.metadata
                    )
        
//      accumulate( MetadataRecord($sources:sources) from $conflictingFormats;
//                      $conflictSourceIDs : unionList( $sources ) 
//                  )
        
//      accumulate( $id: String() from $conflictSourceIDs;
//                      $conflictSources : collectList( cache.getSource($id) ) 
//                  )
        
    then
        log.log("Report: "+$e.getUid()+" has conflict in "+$conflictingProperty+" by: ");
//      for(Source source : (List<Source>)$conflictSources) {
//          log.debug("    "+source.getName()+" "+source.getVersion()+ "["+source.getId()+"]");         
//      }
        for(MetadataRecord conflict : (List<MetadataRecord>)$conflicts) {
            log.log("    "+conflict.getValue());
            List<String> sources = conflict.getSources();
            for(String sourceID : sources) {
                Source source = cache.getSource(sourceID);
                log.log("        "+source.getName()+" "+source.getVersion()+ " ["+source.getId()+"]");          
            }           
        }
        retract($e);

end

rule "REPORT: element without conflicts"
        salience 0
    when 
        $e : Element()
        
        Number( intValue == 0 ) from accumulate( $m : MetadataRecord( 
                status=="CONFLICT"
            ) from $e.metadata;
                count($m)
        )
        
    then
        log.log("Report: "+$e.getUid()+" has no conflicts");
        retract($e);
end
 