package c3po.basic

import java.util.List
import java.util.Set

import com.petpet.c3po.datamodel.Element
import com.petpet.c3po.datamodel.MetadataRecord
import com.petpet.c3po.datamodel.MetadataRecord.Status
import com.petpet.c3po.datamodel.Source
import com.petpet.c3po.adaptor.rules.drools.LogCollector

global com.petpet.c3po.adaptor.rules.drools.LogCollector logger;
global com.petpet.c3po.adaptor.rules.drools.ConflictCollector conflicts;
global java.lang.Integer loglevel;


/**
 * This is run every time, once, before all others
 *
rule "Initialize"
        salience 1000
    when 
    then
        logger.debug("DR Running" );   
end
/**/

/**
 * This rule checks if there exists a property, marked as conflicting, that has
 * no more other properties that provoke the conflict. 
 * If no conflicting properties are found, the status is set to "SINGLE_RESULT"
 * and all (in fact non-)conflicting records are merged together.
 *
 * This rule has a high priority, so whenever we see a property is conflicting, 
 * there must be at least one property with a conflicting value.
 */
rule "Single value, no more Conflict - Resolution"
        salience 999
    when 
        $e : Element()

        $md1 : MetadataRecord(
            status==Status.CONFLICT.toString()
        ) from $e.metadata

        Number( intValue == 0 ) from accumulate( $m : MetadataRecord( 
                property.id == $md1.property.id,
                value != $md1.value
            ) from $e.metadata;
                count($m)
        )

        $mdsSame : List() from accumulate( $m : MetadataRecord( 
                this != $md1, 
                property.id == $md1.property.id,
                value == $md1.value
            ) from $e.metadata;
                collectList($m)
        )

    then
        logger.log(loglevel, "no more conflicts on "+$md1.getProperty().getId());
        
        $md1.setStatus(Status.SINGLE_RESULT.toString());
        modify($e) {
            mergeMetadata($md1, $mdsSame)
        }
        logger.log(loglevel, "    -> merge and set status to Single Result!");
end
/**/


/**
 * REPORT Rules
 */

rule "REPORT: element with conflicts"
        salience 0
    when 
        $e : Element()

        $conflicts : Set() from collect(
            MetadataRecord(
                status==Status.CONFLICT.toString()
            ) from $e.metadata
        )
        
    then
        logger.log(LogCollector.INFO, "Report: "+$e.getUid()+" has conflicts: ");
        
        java.util.SortedSet<MetadataRecord> sorted = 
            new java.util.TreeSet<MetadataRecord>(LogCollector.getMetadataSorter());
        sorted.addAll((Set<MetadataRecord>)$conflicts);
        for(MetadataRecord conflict : sorted) {
            logger.logMetadataRecord(LogCollector.INFO, conflict);           
            conflicts.addConflict(conflict.getProperty().getId(), $e);
        }
        retract($e);

end

rule "REPORT: element without conflicts"
        salience 0
    when 
        $e : Element()
        
        Number( intValue == 0 ) from accumulate(
            $m : MetadataRecord( 
                status==Status.CONFLICT.toString()
            ) from $e.metadata;
                count($m)
        )
        
    then
        logger.log(loglevel, "Report: "+$e.getUid()+" has no conflicts");
        retract($e);
end
 